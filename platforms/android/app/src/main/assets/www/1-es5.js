function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1], {
  /***/
  "./node_modules/@ionic/core/dist/esm/core-ca0488fc.js":
  /*!************************************************************!*\
    !*** ./node_modules/@ionic/core/dist/esm/core-ca0488fc.js ***!
    \************************************************************/

  /*! exports provided: H, a, b, c, d, e, f, g, h, i, j, p, r, w */

  /***/
  function node_modulesIonicCoreDistEsmCoreCa0488fcJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "H", function () {
      return Host;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "a", function () {
      return patchEsm;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "b", function () {
      return bootstrapLazy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "c", function () {
      return createEvent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "d", function () {
      return getIonMode;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "e", function () {
      return getElement;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "f", function () {
      return readTask;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "g", function () {
      return globals;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "h", function () {
      return h;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "i", function () {
      return getAssetPath;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "j", function () {
      return getMode;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "p", function () {
      return patchBrowser;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "r", function () {
      return registerInstance;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "w", function () {
      return writeTask;
    });
    /* harmony import */


    var _config_3c7f3790_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./config-3c7f3790.js */
    "./node_modules/@ionic/core/dist/esm/config-3c7f3790.js");

    var NAMESPACE = 'ionic';
    var queueCongestion = 0;
    var queuePending = false;
    var scopeId;
    var contentRef;
    var hostTagName;
    var useNativeShadowDom = false;
    var checkSlotFallbackVisibility = false;
    var checkSlotRelocate = false;
    var isSvgMode = false;
    var win = window;
    var doc = document;
    var plt = {
      $flags$: 0,
      $resourcesUrl$: '',
      jmp: function jmp(h) {
        return h();
      },
      raf: function raf(h) {
        return requestAnimationFrame(h);
      },
      ael: function ael(el, eventName, listener, opts) {
        return el.addEventListener(eventName, listener, opts);
      },
      rel: function rel(el, eventName, listener, opts) {
        return el.removeEventListener(eventName, listener, opts);
      }
    };

    var supportsShadowDom =
    /*@__PURE__*/
    function () {
      return !!doc.documentElement.attachShadow;
    }();

    var supportsListenerOptions =
    /*@__PURE__*/
    function () {
      var supportsListenerOptions = false;

      try {
        doc.addEventListener('e', null, Object.defineProperty({}, 'passive', {
          get: function get() {
            supportsListenerOptions = true;
          }
        }));
      } catch (e) {}

      return supportsListenerOptions;
    }();

    var supportsConstructibleStylesheets =
    /*@__PURE__*/
    function () {
      try {
        new CSSStyleSheet();
        return true;
      } catch (e) {}

      return false;
    }();

    var hostRefs = new WeakMap();

    var getHostRef = function getHostRef(ref) {
      return hostRefs.get(ref);
    };

    var registerInstance = function registerInstance(lazyInstance, hostRef) {
      return hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);
    };

    var registerHost = function registerHost(elm) {
      var hostRef = {
        $flags$: 0,
        $hostElement$: elm,
        $instanceValues$: new Map()
      };
      {
        hostRef.$onInstancePromise$ = new Promise(function (r) {
          return hostRef.$onInstanceResolve$ = r;
        });
      }
      {
        hostRef.$onReadyPromise$ = new Promise(function (r) {
          return hostRef.$onReadyResolve$ = r;
        });
        elm['s-p'] = [];
        elm['s-rc'] = [];
      }
      return hostRefs.set(elm, hostRef);
    };

    var isMemberInElement = function isMemberInElement(elm, memberName) {
      return memberName in elm;
    };

    var consoleError = function consoleError(e) {
      return console.error(e);
    };

    var moduleCache =
    /*@__PURE__*/
    new Map();

    var loadModule = function loadModule(cmpMeta, hostRef, hmrVersionId) {
      // loadModuleImport
      var exportName = cmpMeta.$tagName$.replace(/-/g, '_');
      var bundleId = typeof cmpMeta.$lazyBundleIds$ !== 'string' ? cmpMeta.$lazyBundleIds$[hostRef.$modeName$] : cmpMeta.$lazyBundleIds$;
      var module = moduleCache.get(bundleId);

      if (module) {
        return module[exportName];
      }

      return __webpack_require__("./node_modules/@ionic/core/dist/esm lazy recursive ^\\.\\/.*\\.entry\\.js$ include: \\.entry\\.js$ exclude: \\.system\\.entry\\.js$")("./".concat(bundleId, ".entry.js")).then(function (importedModule) {
        {
          moduleCache.set(bundleId, importedModule);
        }
        return importedModule[exportName];
      }, consoleError);
    };

    var styles = new Map();
    var queueDomReads = [];
    var queueDomWrites = [];
    var queueDomWritesLow = [];

    var queueTask = function queueTask(queue, write) {
      return function (cb) {
        queue.push(cb);

        if (!queuePending) {
          queuePending = true;

          if (write && plt.$flags$ & 4
          /* queueSync */
          ) {
              nextTick(flush);
            } else {
            plt.raf(flush);
          }
        }
      };
    };

    var consume = function consume(queue) {
      for (var i = 0; i < queue.length; i++) {
        try {
          queue[i](performance.now());
        } catch (e) {
          consoleError(e);
        }
      }

      queue.length = 0;
    };

    var consumeTimeout = function consumeTimeout(queue, timeout) {
      var i = 0;
      var ts = 0;

      while (i < queue.length && (ts = performance.now()) < timeout) {
        try {
          queue[i++](ts);
        } catch (e) {
          consoleError(e);
        }
      }

      if (i === queue.length) {
        queue.length = 0;
      } else if (i !== 0) {
        queue.splice(0, i);
      }
    };

    var flush = function flush() {
      queueCongestion++; // always force a bunch of medium callbacks to run, but still have
      // a throttle on how many can run in a certain time
      // DOM READS!!!

      consume(queueDomReads);
      var timeout = (plt.$flags$ & 6
      /* queueMask */
      ) === 2
      /* appLoaded */
      ? performance.now() + 10 * Math.ceil(queueCongestion * (1.0 / 22.0)) : Infinity; // DOM WRITES!!!

      consumeTimeout(queueDomWrites, timeout);
      consumeTimeout(queueDomWritesLow, timeout);

      if (queueDomWrites.length > 0) {
        queueDomWritesLow.push.apply(queueDomWritesLow, queueDomWrites);
        queueDomWrites.length = 0;
      }

      if (queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0) {
        // still more to do yet, but we've run out of time
        // let's let this thing cool off and try again in the next tick
        plt.raf(flush);
      } else {
        queueCongestion = 0;
      }
    };

    var nextTick =
    /*@__PURE__*/
    function nextTick(cb) {
      return Promise.resolve().then(cb);
    };

    var readTask =
    /*@__PURE__*/
    queueTask(queueDomReads, false);
    var writeTask =
    /*@__PURE__*/
    queueTask(queueDomWrites, true);
    /**
     * Default style mode id
     */

    /**
     * Reusable empty obj/array
     * Don't add values to these!!
     */

    var EMPTY_OBJ = {};
    /**
     * Namespaces
     */

    var SVG_NS = 'http://www.w3.org/2000/svg';
    var HTML_NS = 'http://www.w3.org/1999/xhtml';

    var isDef = function isDef(v) {
      return v != null;
    };

    var isComplexType = function isComplexType(o) {
      // https://jsperf.com/typeof-fn-object/5
      o = typeof o;
      return o === 'object' || o === 'function';
    };

    var getDynamicImportFunction = function getDynamicImportFunction(namespace) {
      return "__sc_import_".concat(namespace.replace(/\s|-/g, '_'));
    };

    var patchEsm = function patchEsm() {
      // @ts-ignore
      if (!(win.CSS && win.CSS.supports && win.CSS.supports('color', 'var(--c)'))) {
        // @ts-ignore
        return __webpack_require__.e(
        /*! import() | css-shim-206ea950-3169f23e-js */
        "css-shim-206ea950-3169f23e-js").then(__webpack_require__.t.bind(null,
        /*! ./css-shim-206ea950-3169f23e.js */
        "./node_modules/@ionic/core/dist/esm/css-shim-206ea950-3169f23e.js", 7)).then(function () {
          plt.$cssShim$ = win.__stencil_cssshim;

          if (plt.$cssShim$) {
            return plt.$cssShim$.initShim();
          }
        });
      }

      return Promise.resolve();
    };

    var patchBrowser = function patchBrowser() {
      var importMeta, regex, scriptElm, opts, resourcesUrl;
      return regeneratorRuntime.async(function patchBrowser$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              plt.$cssShim$ = win.__stencil_cssshim;
              // @ts-ignore
              importMeta = "";
              regex = new RegExp("/".concat(NAMESPACE, "(\\.esm)?\\.js($|\\?|#)"));
              scriptElm = Array.from(doc.querySelectorAll('script')).find(function (s) {
                return regex.test(s.src) || s.getAttribute('data-stencil-namespace') === NAMESPACE;
              });
              opts = scriptElm['data-opts'];

              if (!(importMeta !== '')) {
                _context.next = 9;
                break;
              }

              return _context.abrupt("return", Object.assign(Object.assign({}, opts), {
                resourcesUrl: new URL('.', importMeta).href
              }));

            case 9:
              resourcesUrl = new URL('.', new URL(scriptElm.getAttribute('data-resources-url') || scriptElm.src, win.location.href));
              patchDynamicImport(resourcesUrl.href);

              if (window.customElements) {
                _context.next = 14;
                break;
              }

              _context.next = 14;
              return regeneratorRuntime.awrap(__webpack_require__.e(
              /*! import() | dom-96781eef-a2fb04dd-js */
              "dom-96781eef-a2fb04dd-js").then(__webpack_require__.t.bind(null,
              /*! ./dom-96781eef-a2fb04dd.js */
              "./node_modules/@ionic/core/dist/esm/dom-96781eef-a2fb04dd.js", 7)));

            case 14:
              return _context.abrupt("return", Object.assign(Object.assign({}, opts), {
                resourcesUrl: resourcesUrl.href
              }));

            case 15:
            case "end":
              return _context.stop();
          }
        }
      });
    };

    var patchDynamicImport = function patchDynamicImport(base) {
      var importFunctionName = getDynamicImportFunction(NAMESPACE);

      try {
        // There is a caching issue in V8, that breaks using import() in Function
        // By generating a random string, we can workaround it
        // Check https://bugs.chromium.org/p/v8/issues/detail?id=9558 for more info
        win[importFunctionName] = new Function('w', "return import(w);//".concat(Math.random()));
      } catch (e) {
        var moduleMap = new Map();

        win[importFunctionName] = function (src) {
          var url = new URL(src, base).href;
          var mod = moduleMap.get(url);

          if (!mod) {
            var script = doc.createElement('script');
            script.type = 'module';
            script.src = URL.createObjectURL(new Blob(["import * as m from '".concat(url, "'; window.").concat(importFunctionName, ".m = m;")], {
              type: 'application/javascript'
            }));
            mod = new Promise(function (resolve) {
              script.onload = function () {
                resolve(win[importFunctionName].m);
                script.remove();
              };
            });
            moduleMap.set(url, mod);
            doc.head.appendChild(script);
          }

          return mod;
        };
      }
    };

    var parsePropertyValue = function parsePropertyValue(propValue, propType) {
      // ensure this value is of the correct prop type
      if (propValue != null && !isComplexType(propValue)) {
        if (propType & 4
        /* Boolean */
        ) {
            // per the HTML spec, any string value means it is a boolean true value
            // but we'll cheat here and say that the string "false" is the boolean false
            return propValue === 'false' ? false : propValue === '' || !!propValue;
          }

        if (propType & 2
        /* Number */
        ) {
            // force it to be a number
            return parseFloat(propValue);
          }

        if (propType & 1
        /* String */
        ) {
            // could have been passed as a number or boolean
            // but we still want it as a string
            return String(propValue);
          } // redundant return here for better minification


        return propValue;
      } // not sure exactly what type we want
      // so no need to change to a different type


      return propValue;
    };

    var CONTENT_REF_ID = 'r';
    var ORG_LOCATION_ID = 'o';
    var SLOT_NODE_ID = 's';
    var TEXT_NODE_ID = 't';
    var HYDRATED_CLASS = 'hydrated';
    var HYDRATE_ID = 's-id';
    var HYDRATE_CHILD_ID = 'c-id';
    var XLINK_NS = 'http://www.w3.org/1999/xlink';
    var rootAppliedStyles = new WeakMap();

    var registerStyle = function registerStyle(scopeId, cssText, allowCS) {
      var style = styles.get(scopeId);

      if (supportsConstructibleStylesheets && allowCS) {
        style = style || new CSSStyleSheet();
        style.replace(cssText);
      } else {
        style = cssText;
      }

      styles.set(scopeId, style);
    };

    var addStyle = function addStyle(styleContainerNode, cmpMeta, mode, hostElm) {
      var scopeId = getScopeId(cmpMeta.$tagName$, mode);
      var style = styles.get(scopeId); // if an element is NOT connected then getRootNode() will return the wrong root node
      // so the fallback is to always use the document for the root node in those cases

      styleContainerNode = styleContainerNode.nodeType === 11
      /* DocumentFragment */
      ? styleContainerNode : doc;

      if (!style) {
        scopeId = getScopeId(cmpMeta.$tagName$);
        style = styles.get(scopeId);
      }

      if (style) {
        if (typeof style === 'string') {
          styleContainerNode = styleContainerNode.head || styleContainerNode;
          var appliedStyles = rootAppliedStyles.get(styleContainerNode);
          var styleElm;

          if (!appliedStyles) {
            rootAppliedStyles.set(styleContainerNode, appliedStyles = new Set());
          }

          if (!appliedStyles.has(scopeId)) {
            if (styleContainerNode.host && (styleElm = styleContainerNode.firstElementChild) && styleElm.tagName === 'STYLE') {
              // This is only happening on native shadow-dom, do not needs CSS var shim
              styleElm.innerHTML = style;
            } else {
              if (plt.$cssShim$) {
                styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10
                /* needsScopedEncapsulation */
                ));
                var newScopeId = styleElm['s-sc'];

                if (newScopeId) {
                  scopeId = newScopeId; // we don't want to add this styleID to the appliedStyles Set
                  // since the cssVarShim might need to apply several different
                  // stylesheets for the same component

                  appliedStyles = null;
                }
              } else {
                styleElm = doc.createElement('style');
                styleElm.setAttribute('data-styles', '');
                styleElm.innerHTML = style;
              }

              styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));
            }

            if (appliedStyles) {
              appliedStyles.add(scopeId);
            }
          }
        } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
          styleContainerNode.adoptedStyleSheets = [].concat(_toConsumableArray(styleContainerNode.adoptedStyleSheets), [style]);
        }
      }

      return scopeId;
    };

    var attachStyles = function attachStyles(elm, cmpMeta, mode) {
      var scopeId = addStyle(supportsShadowDom && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, mode, elm);

      if (cmpMeta.$flags$ & 10
      /* needsScopedEncapsulation */
      ) {
          // only required when we're NOT using native shadow dom (slot)
          // or this browser doesn't support native shadow dom
          // and this host element was NOT created with SSR
          // let's pick out the inner content for slot projection
          // create a node to represent where the original
          // content was first placed, which is useful later on
          // DOM WRITE!!
          elm['s-sc'] = scopeId;
          elm.classList.add(scopeId + '-h');

          if (cmpMeta.$flags$ & 2
          /* scopedCssEncapsulation */
          ) {
              elm.classList.add(scopeId + '-s');
            }
        }
    };

    var getScopeId = function getScopeId(tagName, mode) {
      return 'sc-' + (mode ? tagName + '-' + mode : tagName);
    };

    var convertScopedToShadow = function convertScopedToShadow(css) {
      return css.replace(/\/\*!@([^\/]+)\*\/[^\{]+\{/g, '$1{');
    };
    /**
     * Production h() function based on Preact by
     * Jason Miller (@developit)
     * Licensed under the MIT License
     * https://github.com/developit/preact/blob/master/LICENSE
     *
     * Modified for Stencil's compiler and vdom
     */
    // const stack: any[] = [];
    // export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;
    // export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;


    var h = function h(nodeName, vnodeData) {
      var child = null;
      var key = null;
      var slotName = null;
      var simple = false;
      var lastSimple = false;
      var vNodeChildren = [];

      var walk = function walk(c) {
        for (var i = 0; i < c.length; i++) {
          child = c[i];

          if (Array.isArray(child)) {
            walk(child);
          } else if (child != null && typeof child !== 'boolean') {
            if (simple = typeof nodeName !== 'function' && !isComplexType(child)) {
              child = String(child);
            }

            if (simple && lastSimple) {
              // If the previous child was simple (string), we merge both
              vNodeChildren[vNodeChildren.length - 1].$text$ += child;
            } else {
              // Append a new vNode, if it's text, we create a text vNode
              vNodeChildren.push(simple ? newVNode(null, child) : child);
            }

            lastSimple = simple;
          }
        }
      };

      for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        children[_key - 2] = arguments[_key];
      }

      walk(children);

      if (vnodeData) {
        // normalize class / classname attributes
        if (vnodeData.key) {
          key = vnodeData.key;
        }

        if (vnodeData.name) {
          slotName = vnodeData.name;
        }

        {
          var classData = vnodeData.className || vnodeData.class;

          if (classData) {
            vnodeData.class = typeof classData !== 'object' ? classData : Object.keys(classData).filter(function (k) {
              return classData[k];
            }).join(' ');
          }
        }
      }

      if (typeof nodeName === 'function') {
        // nodeName is a functional component
        return nodeName(vnodeData, vNodeChildren, vdomFnUtils);
      }

      var vnode = newVNode(nodeName, null);
      vnode.$attrs$ = vnodeData;

      if (vNodeChildren.length > 0) {
        vnode.$children$ = vNodeChildren;
      }

      {
        vnode.$key$ = key;
      }
      {
        vnode.$name$ = slotName;
      }
      return vnode;
    };

    var newVNode = function newVNode(tag, text) {
      var vnode = {
        $flags$: 0,
        $tag$: tag,
        $text$: text,
        $elm$: null,
        $children$: null
      };
      {
        vnode.$attrs$ = null;
      }
      {
        vnode.$key$ = null;
      }
      {
        vnode.$name$ = null;
      }
      return vnode;
    };

    var Host = {};

    var isHost = function isHost(node) {
      return node && node.$tag$ === Host;
    };

    var vdomFnUtils = {
      'forEach': function forEach(children, cb) {
        return children.map(convertToPublic).forEach(cb);
      },
      'map': function map(children, cb) {
        return children.map(convertToPublic).map(cb).map(convertToPrivate);
      }
    };

    var convertToPublic = function convertToPublic(node) {
      return {
        vattrs: node.$attrs$,
        vchildren: node.$children$,
        vkey: node.$key$,
        vname: node.$name$,
        vtag: node.$tag$,
        vtext: node.$text$
      };
    };

    var convertToPrivate = function convertToPrivate(node) {
      var vnode = newVNode(node.vtag, node.vtext);
      vnode.$attrs$ = node.vattrs;
      vnode.$children$ = node.vchildren;
      vnode.$key$ = node.vkey;
      vnode.$name$ = node.vname;
      return vnode;
    };
    /**
     * Production setAccessor() function based on Preact by
     * Jason Miller (@developit)
     * Licensed under the MIT License
     * https://github.com/developit/preact/blob/master/LICENSE
     *
     * Modified for Stencil's compiler and vdom
     */


    var setAccessor = function setAccessor(elm, memberName, oldValue, newValue, isSvg, flags) {
      if (oldValue === newValue) {
        return;
      }

      var isProp = isMemberInElement(elm, memberName);
      var ln = memberName.toLowerCase();

      if (memberName === 'class') {
        var classList = elm.classList;
        var oldClasses = parseClassList(oldValue);
        var newClasses = parseClassList(newValue);
        classList.remove.apply(classList, _toConsumableArray(oldClasses.filter(function (c) {
          return c && !newClasses.includes(c);
        })));
        classList.add.apply(classList, _toConsumableArray(newClasses.filter(function (c) {
          return c && !oldClasses.includes(c);
        })));
      } else if (memberName === 'style') {
        // update style attribute, css properties and values
        {
          for (var prop in oldValue) {
            if (!newValue || newValue[prop] == null) {
              if (prop.includes('-')) {
                elm.style.removeProperty(prop);
              } else {
                elm.style[prop] = '';
              }
            }
          }
        }

        for (var _prop in newValue) {
          if (!oldValue || newValue[_prop] !== oldValue[_prop]) {
            if (_prop.includes('-')) {
              elm.style.setProperty(_prop, newValue[_prop]);
            } else {
              elm.style[_prop] = newValue[_prop];
            }
          }
        }
      } else if (memberName === 'key') ;else if (memberName === 'ref') {
        // minifier will clean this up
        if (newValue) {
          newValue(elm);
        }
      } else if (!isProp && memberName[0] === 'o' && memberName[1] === 'n') {
        // Event Handlers
        // so if the member name starts with "on" and the 3rd characters is
        // a capital letter, and it's not already a member on the element,
        // then we're assuming it's an event listener
        if (memberName[2] === '-') {
          // on- prefixed events
          // allows to be explicit about the dom event to listen without any magic
          // under the hood:
          // <my-cmp on-click> // listens for "click"
          // <my-cmp on-Click> // listens for "Click"
          // <my-cmp on-ionChange> // listens for "ionChange"
          // <my-cmp on-EVENTS> // listens for "EVENTS"
          memberName = memberName.slice(3);
        } else if (isMemberInElement(win, ln)) {
          // standard event
          // the JSX attribute could have been "onMouseOver" and the
          // member name "onmouseover" is on the window's prototype
          // so let's add the listener "mouseover", which is all lowercased
          memberName = ln.slice(2);
        } else {
          // custom event
          // the JSX attribute could have been "onMyCustomEvent"
          // so let's trim off the "on" prefix and lowercase the first character
          // and add the listener "myCustomEvent"
          // except for the first character, we keep the event name case
          memberName = ln[2] + memberName.slice(3);
        }

        if (oldValue) {
          plt.rel(elm, memberName, oldValue, false);
        }

        if (newValue) {
          plt.ael(elm, memberName, newValue, false);
        }
      } else {
        // Set property if it exists and it's not a SVG
        var isComplex = isComplexType(newValue);

        if ((isProp || isComplex && newValue !== null) && !isSvg) {
          try {
            if (!elm.tagName.includes('-')) {
              var n = newValue == null ? '' : newValue; // Workaround for Safari, moving the <input> caret when re-assigning the same valued
              // tslint:disable-next-line: triple-equals

              if (oldValue == null || elm[memberName] != n) {
                elm[memberName] = n;
              }
            } else {
              elm[memberName] = newValue;
            }
          } catch (e) {}
        }
        /**
         * Need to manually update attribute if:
         * - memberName is not an attribute
         * - if we are rendering the host element in order to reflect attribute
         * - if it's a SVG, since properties might not work in <svg>
         * - if the newValue is null/undefined or 'false'.
         */


        var xlink = false;
        {
          if (ln !== (ln = ln.replace(/^xlink\:?/, ''))) {
            memberName = ln;
            xlink = true;
          }
        }

        if (newValue == null || newValue === false) {
          if (xlink) {
            elm.removeAttributeNS(XLINK_NS, memberName);
          } else {
            elm.removeAttribute(memberName);
          }
        } else if ((!isProp || flags & 4
        /* isHost */
        || isSvg) && !isComplex) {
          newValue = newValue === true ? '' : newValue;

          if (xlink) {
            elm.setAttributeNS(XLINK_NS, memberName, newValue);
          } else {
            elm.setAttribute(memberName, newValue);
          }
        }
      }
    };

    var parseClassListRegex = /\s/;

    var parseClassList = function parseClassList(value) {
      return !value ? [] : value.split(parseClassListRegex);
    };

    var updateElement = function updateElement(oldVnode, newVnode, isSvgMode, memberName) {
      // if the element passed in is a shadow root, which is a document fragment
      // then we want to be adding attrs/props to the shadow root's "host" element
      // if it's not a shadow root, then we add attrs/props to the same element
      var elm = newVnode.$elm$.nodeType === 11
      /* DocumentFragment */
      && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
      var oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
      var newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
      {
        // remove attributes no longer present on the vnode by setting them to undefined
        for (memberName in oldVnodeAttrs) {
          if (!(memberName in newVnodeAttrs)) {
            setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);
          }
        }
      } // add new & update changed attributes

      for (memberName in newVnodeAttrs) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);
      }
    };

    var createElm = function createElm(oldParentVNode, newParentVNode, childIndex, parentElm) {
      // tslint:disable-next-line: prefer-const
      var newVNode = newParentVNode.$children$[childIndex];
      var i = 0;
      var elm;
      var childNode;
      var oldVNode;

      if (!useNativeShadowDom) {
        // remember for later we need to check to relocate nodes
        checkSlotRelocate = true;

        if (newVNode.$tag$ === 'slot') {
          if (scopeId) {
            // scoped css needs to add its scoped id to the parent element
            parentElm.classList.add(scopeId + '-s');
          }

          newVNode.$flags$ |= newVNode.$children$ ? // slot element has fallback content
          // still create an element that "mocks" the slot element
          2
          /* isSlotFallback */
          // slot element does not have fallback content
          // create an html comment we'll use to always reference
          // where actual slot content should sit next to
          : 1
          /* isSlotReference */
          ;
        }
      }

      if (newVNode.$text$ !== null) {
        // create text node
        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);
      } else if (newVNode.$flags$ & 1
      /* isSlotReference */
      ) {
          // create a slot reference node
          elm = newVNode.$elm$ = doc.createTextNode('');
        } else {
        if (!isSvgMode) {
          isSvgMode = newVNode.$tag$ === 'svg';
        } // create element


        elm = newVNode.$elm$ = doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, newVNode.$flags$ & 2
        /* isSlotFallback */
        ? 'slot-fb' : newVNode.$tag$);

        if (isSvgMode && newVNode.$tag$ === 'foreignObject') {
          isSvgMode = false;
        } // add css classes, attrs, props, listeners, etc.


        {
          updateElement(null, newVNode, isSvgMode);
        }

        if (isDef(scopeId) && elm['s-si'] !== scopeId) {
          // if there is a scopeId and this is the initial render
          // then let's add the scopeId as a css class
          elm.classList.add(elm['s-si'] = scopeId);
        }

        if (newVNode.$children$) {
          for (i = 0; i < newVNode.$children$.length; ++i) {
            // create the node
            childNode = createElm(oldParentVNode, newVNode, i, elm); // return node could have been null

            if (childNode) {
              // append our new node
              elm.appendChild(childNode);
            }
          }
        }

        {
          if (newVNode.$tag$ === 'svg') {
            // Only reset the SVG context when we're exiting <svg> element
            isSvgMode = false;
          } else if (elm.tagName === 'foreignObject') {
            // Reenter SVG context when we're exiting <foreignObject> element
            isSvgMode = true;
          }
        }
      }

      {
        elm['s-hn'] = hostTagName;

        if (newVNode.$flags$ & (2
        /* isSlotFallback */
        | 1
        /* isSlotReference */
        )) {
          // remember the content reference comment
          elm['s-sr'] = true; // remember the content reference comment

          elm['s-cr'] = contentRef; // remember the slot name, or empty string for default slot

          elm['s-sn'] = newVNode.$name$ || ''; // check if we've got an old vnode for this slot

          oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];

          if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {
            // we've got an old slot vnode and the wrapper is being replaced
            // so let's move the old slot content back to it's original location
            putBackInOriginalLocation(oldParentVNode.$elm$, false);
          }
        }
      }
      return elm;
    };

    var putBackInOriginalLocation = function putBackInOriginalLocation(parentElm, recursive) {
      plt.$flags$ |= 1
      /* isTmpDisconnected */
      ;
      var oldSlotChildNodes = parentElm.childNodes;

      for (var i = oldSlotChildNodes.length - 1; i >= 0; i--) {
        var childNode = oldSlotChildNodes[i];

        if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {
          // // this child node in the old element is from another component
          // // remove this node from the old slot's parent
          // childNode.remove();
          // and relocate it back to it's original location
          parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode)); // remove the old original location comment entirely
          // later on the patch function will know what to do
          // and move this to the correct spot in need be

          childNode['s-ol'].remove();
          childNode['s-ol'] = undefined;
          checkSlotRelocate = true;
        }

        if (recursive) {
          putBackInOriginalLocation(childNode, recursive);
        }
      }

      plt.$flags$ &= ~1
      /* isTmpDisconnected */
      ;
    };

    var addVnodes = function addVnodes(parentElm, before, parentVNode, vnodes, startIdx, endIdx) {
      var containerElm = parentElm['s-cr'] && parentElm['s-cr'].parentNode || parentElm;
      var childNode;

      if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
        containerElm = containerElm.shadowRoot;
      }

      for (; startIdx <= endIdx; ++startIdx) {
        if (vnodes[startIdx]) {
          childNode = createElm(null, parentVNode, startIdx, parentElm);

          if (childNode) {
            vnodes[startIdx].$elm$ = childNode;
            containerElm.insertBefore(childNode, referenceNode(before));
          }
        }
      }
    };

    var removeVnodes = function removeVnodes(vnodes, startIdx, endIdx, vnode, elm) {
      for (; startIdx <= endIdx; ++startIdx) {
        if (vnode = vnodes[startIdx]) {
          elm = vnode.$elm$;
          callNodeRefs(vnode);
          {
            // we're removing this element
            // so it's possible we need to show slot fallback content now
            checkSlotFallbackVisibility = true;

            if (elm['s-ol']) {
              // remove the original location comment
              elm['s-ol'].remove();
            } else {
              // it's possible that child nodes of the node
              // that's being removed are slot nodes
              putBackInOriginalLocation(elm, true);
            }
          } // remove the vnode's element from the dom

          elm.remove();
        }
      }
    };

    var updateChildren = function updateChildren(parentElm, oldCh, newVNode, newCh) {
      var oldStartIdx = 0;
      var newStartIdx = 0;
      var idxInOld = 0;
      var i = 0;
      var oldEndIdx = oldCh.length - 1;
      var oldStartVnode = oldCh[0];
      var oldEndVnode = oldCh[oldEndIdx];
      var newEndIdx = newCh.length - 1;
      var newStartVnode = newCh[0];
      var newEndVnode = newCh[newEndIdx];
      var node;
      var elmToMove;

      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (oldStartVnode == null) {
          // Vnode might have been moved left
          oldStartVnode = oldCh[++oldStartIdx];
        } else if (oldEndVnode == null) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (newStartVnode == null) {
          newStartVnode = newCh[++newStartIdx];
        } else if (newEndVnode == null) {
          newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldStartVnode, newStartVnode)) {
          patch(oldStartVnode, newStartVnode);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (isSameVnode(oldEndVnode, newEndVnode)) {
          patch(oldEndVnode, newEndVnode);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldStartVnode, newEndVnode)) {
          // Vnode moved right
          if (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot') {
            putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
          }

          patch(oldStartVnode, newEndVnode);
          parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldEndVnode, newStartVnode)) {
          // Vnode moved left
          if (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot') {
            putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
          }

          patch(oldEndVnode, newStartVnode);
          parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          // createKeyToOldIdx
          idxInOld = -1;
          {
            for (i = oldStartIdx; i <= oldEndIdx; ++i) {
              if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {
                idxInOld = i;
                break;
              }
            }
          }

          if (idxInOld >= 0) {
            elmToMove = oldCh[idxInOld];

            if (elmToMove.$tag$ !== newStartVnode.$tag$) {
              node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);
            } else {
              patch(elmToMove, newStartVnode);
              oldCh[idxInOld] = undefined;
              node = elmToMove.$elm$;
            }

            newStartVnode = newCh[++newStartIdx];
          } else {
            // new element
            node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);
            newStartVnode = newCh[++newStartIdx];
          }

          if (node) {
            {
              parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
            }
          }
        }
      }

      if (oldStartIdx > oldEndIdx) {
        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);
      } else if (newStartIdx > newEndIdx) {
        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
      }
    };

    var isSameVnode = function isSameVnode(vnode1, vnode2) {
      // compare if two vnode to see if they're "technically" the same
      // need to have the same element tag, and same key to be the same
      if (vnode1.$tag$ === vnode2.$tag$) {
        if (vnode1.$tag$ === 'slot') {
          return vnode1.$name$ === vnode2.$name$;
        }

        {
          return vnode1.$key$ === vnode2.$key$;
        }
        return true;
      }

      return false;
    };

    var referenceNode = function referenceNode(node) {
      // this node was relocated to a new location in the dom
      // because of some other component's slot
      // but we still have an html comment in place of where
      // it's original location was according to it's original vdom
      return node && node['s-ol'] || node;
    };

    var parentReferenceNode = function parentReferenceNode(node) {
      return (node['s-ol'] ? node['s-ol'] : node).parentNode;
    };

    var patch = function patch(oldVNode, newVNode) {
      var elm = newVNode.$elm$ = oldVNode.$elm$;
      var oldChildren = oldVNode.$children$;
      var newChildren = newVNode.$children$;
      var defaultHolder;
      {
        // test if we're rendering an svg element, or still rendering nodes inside of one
        // only add this to the when the compiler sees we're using an svg somewhere
        isSvgMode = elm && elm.parentNode && elm.ownerSVGElement !== undefined;
        isSvgMode = newVNode.$tag$ === 'svg' ? true : newVNode.$tag$ === 'foreignObject' ? false : isSvgMode;
      }

      if (newVNode.$text$ === null) {
        // element node
        {
          if (newVNode.$tag$ === 'slot') ;else {
            // either this is the first render of an element OR it's an update
            // AND we already know it's possible it could have changed
            // this updates the element's css classes, attrs, props, listeners, etc.
            updateElement(oldVNode, newVNode, isSvgMode);
          }
        }

        if (oldChildren !== null && newChildren !== null) {
          // looks like there's child vnodes for both the old and new vnodes
          updateChildren(elm, oldChildren, newVNode, newChildren);
        } else if (newChildren !== null) {
          // no old child vnodes, but there are new child vnodes to add
          if (oldVNode.$text$ !== null) {
            // the old vnode was text, so be sure to clear it out
            elm.textContent = '';
          } // add the new vnode children


          addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);
        } else if (oldChildren !== null) {
          // no new child vnodes, but there are old child vnodes to remove
          removeVnodes(oldChildren, 0, oldChildren.length - 1);
        }
      } else if (defaultHolder = elm['s-cr']) {
        // this element has slotted content
        defaultHolder.parentNode.textContent = newVNode.$text$;
      } else if (oldVNode.$text$ !== newVNode.$text$) {
        // update the text content for the text only vnode
        // and also only if the text is different than before
        elm.data = newVNode.$text$;
      }

      if (isSvgMode && newVNode.$tag$ === 'svg') {
        isSvgMode = false;
      }
    };

    var updateFallbackSlotVisibility = function updateFallbackSlotVisibility(elm) {
      // tslint:disable-next-line: prefer-const
      var childNodes = elm.childNodes;
      var childNode;
      var i;
      var ilen;
      var j;
      var slotNameAttr;
      var nodeType;

      for (i = 0, ilen = childNodes.length; i < ilen; i++) {
        childNode = childNodes[i];

        if (childNode.nodeType === 1
        /* ElementNode */
        ) {
            if (childNode['s-sr']) {
              // this is a slot fallback node
              // get the slot name for this slot reference node
              slotNameAttr = childNode['s-sn']; // by default always show a fallback slot node
              // then hide it if there are other slots in the light dom

              childNode.hidden = false;

              for (j = 0; j < ilen; j++) {
                if (childNodes[j]['s-hn'] !== childNode['s-hn']) {
                  // this sibling node is from a different component
                  nodeType = childNodes[j].nodeType;

                  if (slotNameAttr !== '') {
                    // this is a named fallback slot node
                    if (nodeType === 1
                    /* ElementNode */
                    && slotNameAttr === childNodes[j].getAttribute('slot')) {
                      childNode.hidden = true;
                      break;
                    }
                  } else {
                    // this is a default fallback slot node
                    // any element or text node (with content)
                    // should hide the default fallback slot node
                    if (nodeType === 1
                    /* ElementNode */
                    || nodeType === 3
                    /* TextNode */
                    && childNodes[j].textContent.trim() !== '') {
                      childNode.hidden = true;
                      break;
                    }
                  }
                }
              }
            } // keep drilling down


            updateFallbackSlotVisibility(childNode);
          }
      }
    };

    var relocateNodes = [];

    var relocateSlotContent = function relocateSlotContent(elm) {
      // tslint:disable-next-line: prefer-const
      var childNodes = elm.childNodes;
      var ilen = childNodes.length;
      var i = 0;
      var j = 0;
      var nodeType = 0;
      var childNode;
      var node;
      var hostContentNodes;
      var slotNameAttr;

      for (ilen = childNodes.length; i < ilen; i++) {
        childNode = childNodes[i];

        if (childNode['s-sr'] && (node = childNode['s-cr'])) {
          // first got the content reference comment node
          // then we got it's parent, which is where all the host content is in now
          hostContentNodes = node.parentNode.childNodes;
          slotNameAttr = childNode['s-sn'];

          for (j = hostContentNodes.length - 1; j >= 0; j--) {
            node = hostContentNodes[j];

            if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {
              // let's do some relocating to its new home
              // but never relocate a content reference node
              // that is suppose to always represent the original content location
              nodeType = node.nodeType;

              if ((nodeType === 3
              /* TextNode */
              || nodeType === 8
              /* CommentNode */
              ) && slotNameAttr === '' || nodeType === 1
              /* ElementNode */
              && node.getAttribute('slot') === null && slotNameAttr === '' || nodeType === 1
              /* ElementNode */
              && node.getAttribute('slot') === slotNameAttr) {
                // it's possible we've already decided to relocate this node
                if (!relocateNodes.some(function (r) {
                  return r.$nodeToRelocate$ === node;
                })) {
                  // made some changes to slots
                  // let's make sure we also double check
                  // fallbacks are correctly hidden or shown
                  checkSlotFallbackVisibility = true;
                  node['s-sn'] = slotNameAttr; // add to our list of nodes to relocate

                  relocateNodes.push({
                    $slotRefNode$: childNode,
                    $nodeToRelocate$: node
                  });
                }
              }
            }
          }
        }

        if (childNode.nodeType === 1
        /* ElementNode */
        ) {
            relocateSlotContent(childNode);
          }
      }
    };

    var callNodeRefs = function callNodeRefs(vNode) {
      {
        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
        vNode.$children$ && vNode.$children$.forEach(callNodeRefs);
      }
    };

    var renderVdom = function renderVdom(hostElm, hostRef, cmpMeta, renderFnResults) {
      hostTagName = hostElm.tagName;
      var oldVNode = hostRef.$vnode$ || newVNode(null, null);
      var rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);

      if (cmpMeta.$attrsToReflect$) {
        rootVnode.$attrs$ = rootVnode.$attrs$ || {};
        cmpMeta.$attrsToReflect$.forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              propName = _ref2[0],
              attribute = _ref2[1];

          return rootVnode.$attrs$[attribute] = hostElm[propName];
        });
      }

      rootVnode.$tag$ = null;
      rootVnode.$flags$ |= 4
      /* isHost */
      ;
      hostRef.$vnode$ = rootVnode;
      rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
      {
        scopeId = hostElm['s-sc'];
      }
      {
        contentRef = hostElm['s-cr'];
        useNativeShadowDom = supportsShadowDom && (cmpMeta.$flags$ & 1
        /* shadowDomEncapsulation */
        ) !== 0; // always reset

        checkSlotRelocate = checkSlotFallbackVisibility = false;
      } // synchronous patch

      patch(oldVNode, rootVnode);
      {
        if (checkSlotRelocate) {
          relocateSlotContent(rootVnode.$elm$);

          for (var i = 0; i < relocateNodes.length; i++) {
            var relocateNode = relocateNodes[i];

            if (!relocateNode.$nodeToRelocate$['s-ol']) {
              // add a reference node marking this node's original location
              // keep a reference to this node for later lookups
              var orgLocationNode = doc.createTextNode('');
              orgLocationNode['s-nr'] = relocateNode.$nodeToRelocate$;
              relocateNode.$nodeToRelocate$.parentNode.insertBefore(relocateNode.$nodeToRelocate$['s-ol'] = orgLocationNode, relocateNode.$nodeToRelocate$);
            }
          } // while we're moving nodes around existing nodes, temporarily disable
          // the disconnectCallback from working


          plt.$flags$ |= 1
          /* isTmpDisconnected */
          ;

          for (var _i2 = 0; _i2 < relocateNodes.length; _i2++) {
            var _relocateNode = relocateNodes[_i2]; // by default we're just going to insert it directly
            // after the slot reference node

            var parentNodeRef = _relocateNode.$slotRefNode$.parentNode;
            var insertBeforeNode = _relocateNode.$slotRefNode$.nextSibling;
            var _orgLocationNode = _relocateNode.$nodeToRelocate$['s-ol'];

            while (_orgLocationNode = _orgLocationNode.previousSibling) {
              var refNode = _orgLocationNode['s-nr'];

              if (refNode && refNode['s-sn'] === _relocateNode.$nodeToRelocate$['s-sn'] && parentNodeRef === refNode.parentNode) {
                refNode = refNode.nextSibling;

                if (!refNode || !refNode['s-nr']) {
                  insertBeforeNode = refNode;
                  break;
                }
              }
            }

            if (!insertBeforeNode && parentNodeRef !== _relocateNode.$nodeToRelocate$.parentNode || _relocateNode.$nodeToRelocate$.nextSibling !== insertBeforeNode) {
              // we've checked that it's worth while to relocate
              // since that the node to relocate
              // has a different next sibling or parent relocated
              if (_relocateNode.$nodeToRelocate$ !== insertBeforeNode) {
                // add it back to the dom but in its new home
                parentNodeRef.insertBefore(_relocateNode.$nodeToRelocate$, insertBeforeNode);
              }
            }
          } // done moving nodes around
          // allow the disconnect callback to work again


          plt.$flags$ &= ~1
          /* isTmpDisconnected */
          ;
        }

        if (checkSlotFallbackVisibility) {
          updateFallbackSlotVisibility(rootVnode.$elm$);
        } // always reset


        relocateNodes.length = 0;
      }
    };

    var attachToAncestor = function attachToAncestor(hostRef, ancestorComponent) {
      if (ancestorComponent && !hostRef.$onRenderResolve$) {
        ancestorComponent['s-p'].push(new Promise(function (r) {
          return hostRef.$onRenderResolve$ = r;
        }));
      }
    };

    var scheduleUpdate = function scheduleUpdate(elm, hostRef, cmpMeta, isInitialLoad) {
      {
        hostRef.$flags$ |= 16
        /* isQueuedForUpdate */
        ;
      }

      if (hostRef.$flags$ & 4
      /* isWaitingForChildren */
      ) {
          hostRef.$flags$ |= 512
          /* needsRerender */
          ;
          return;
        }

      var ancestorComponent = hostRef.$ancestorComponent$;
      var instance = hostRef.$lazyInstance$;

      var update = function update() {
        return updateComponent(elm, hostRef, cmpMeta, instance, isInitialLoad);
      };

      var rc = elm['s-rc'];
      attachToAncestor(hostRef, ancestorComponent);
      var promise;

      if (isInitialLoad) {
        {
          hostRef.$flags$ |= 256
          /* isListenReady */
          ;

          if (hostRef.$queuedListeners$) {
            hostRef.$queuedListeners$.forEach(function (_ref3) {
              var _ref4 = _slicedToArray(_ref3, 2),
                  methodName = _ref4[0],
                  event = _ref4[1];

              return safeCall(instance, methodName, event);
            });
            hostRef.$queuedListeners$ = null;
          }
        }
        {
          promise = safeCall(instance, 'componentWillLoad');
        }
      }

      {
        promise = then(promise, function () {
          return safeCall(instance, 'componentWillRender');
        });
      }

      if (rc) {
        // ok, so turns out there are some child host elements
        // waiting on this parent element to load
        // let's fire off all update callbacks waiting
        rc.forEach(function (cb) {
          return cb();
        });
        elm['s-rc'] = undefined;
      } // there is no ancestorc omponent or the ancestor component
      // has already fired off its lifecycle update then
      // fire off the initial update


      return then(promise, function () {
        return writeTask(update);
      });
    };

    var updateComponent = function updateComponent(elm, hostRef, cmpMeta, instance, isInitialLoad) {
      // updateComponent
      if (isInitialLoad) {
        // DOM WRITE!
        attachStyles(elm, cmpMeta, hostRef.$modeName$);
      }

      {
        {
          try {
            // looks like we've got child nodes to render into this host element
            // or we need to update the css class/attrs on the host element
            // DOM WRITE!
            renderVdom(elm, hostRef, cmpMeta, instance.render && instance.render());
          } catch (e) {
            consoleError(e);
          }
        }
      }

      if (plt.$cssShim$) {
        plt.$cssShim$.updateHost(elm);
      }

      {
        hostRef.$flags$ &= ~16
        /* isQueuedForUpdate */
        ;
      }
      {
        hostRef.$flags$ |= 2
        /* hasRendered */
        ;
      }
      {
        var childrenPromises = elm['s-p'];

        var postUpdate = function postUpdate() {
          return postUpdateComponent(elm, hostRef, cmpMeta);
        };

        if (childrenPromises.length === 0) {
          postUpdate();
        } else {
          Promise.all(childrenPromises).then(postUpdate);
          hostRef.$flags$ |= 4
          /* isWaitingForChildren */
          ;
          childrenPromises.length = 0;
        }
      }
    };

    var postUpdateComponent = function postUpdateComponent(elm, hostRef, cmpMeta) {
      var instance = hostRef.$lazyInstance$;
      var ancestorComponent = hostRef.$ancestorComponent$;

      if (!(hostRef.$flags$ & 64
      /* hasLoadedComponent */
      )) {
        hostRef.$flags$ |= 64
        /* hasLoadedComponent */
        ;
        {
          // DOM WRITE!
          // add the css class that this element has officially hydrated
          elm.classList.add(HYDRATED_CLASS);
        }
        {
          safeCall(instance, 'componentDidLoad');
        }
        {
          hostRef.$onReadyResolve$(elm);

          if (!ancestorComponent) {
            appDidLoad();
          }
        }
      } else {
        {
          // we've already loaded this component
          // fire off the user's componentDidUpdate method (if one was provided)
          // componentDidUpdate runs AFTER render() has been called
          // and all child components have finished updating
          safeCall(instance, 'componentDidUpdate');
        }
      }

      {
        hostRef.$onInstanceResolve$(elm);
      } // load events fire from bottom to top
      // the deepest elements load first then bubbles up

      {
        if (hostRef.$onRenderResolve$) {
          hostRef.$onRenderResolve$();
          hostRef.$onRenderResolve$ = undefined;
        }

        if (hostRef.$flags$ & 512
        /* needsRerender */
        ) {
            nextTick(function () {
              return scheduleUpdate(elm, hostRef, cmpMeta, false);
            });
          }

        hostRef.$flags$ &= ~(4
        /* isWaitingForChildren */
        | 512
        /* needsRerender */
        );
      } // ( •_•)
      // ( •_•)>⌐■-■
      // (⌐■_■)
    };

    var _forceUpdate = function forceUpdate(elm, cmpMeta) {
      {
        var hostRef = getHostRef(elm);

        if ((hostRef.$flags$ & (2
        /* hasRendered */
        | 16
        /* isQueuedForUpdate */
        )) === 2
        /* hasRendered */
        ) {
            scheduleUpdate(elm, hostRef, cmpMeta, false);
          }
      }
    };

    var appDidLoad = function appDidLoad() {
      // on appload
      // we have finish the first big initial render
      {
        doc.documentElement.classList.add(HYDRATED_CLASS);
      }
      {
        plt.$flags$ |= 2
        /* appLoaded */
        ;
      }
    };

    var safeCall = function safeCall(instance, method, arg) {
      if (instance && instance[method]) {
        try {
          return instance[method](arg);
        } catch (e) {
          consoleError(e);
        }
      }

      return undefined;
    };

    var then = function then(promise, thenFn) {
      return promise && promise.then ? promise.then(thenFn) : thenFn();
    };

    var getValue = function getValue(ref, propName) {
      return getHostRef(ref).$instanceValues$.get(propName);
    };

    var setValue = function setValue(ref, propName, newVal, cmpMeta) {
      // check our new property value against our internal value
      var hostRef = getHostRef(ref);
      var elm = hostRef.$hostElement$;
      var oldVal = hostRef.$instanceValues$.get(propName);
      var flags = hostRef.$flags$;
      var instance = hostRef.$lazyInstance$;
      newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);

      if (newVal !== oldVal && (!(flags & 8
      /* isConstructingInstance */
      ) || oldVal === undefined)) {
        // gadzooks! the property's value has changed!!
        // set our new value!
        hostRef.$instanceValues$.set(propName, newVal);

        if (instance) {
          // get an array of method names of watch functions to call
          if (cmpMeta.$watchers$ && flags & 128
          /* isWatchReady */
          ) {
              var watchMethods = cmpMeta.$watchers$[propName];

              if (watchMethods) {
                // this instance is watching for when this property changed
                watchMethods.forEach(function (watchMethodName) {
                  try {
                    // fire off each of the watch methods that are watching this property
                    instance[watchMethodName](newVal, oldVal, propName);
                  } catch (e) {
                    consoleError(e);
                  }
                });
              }
            }

          if ((flags & (2
          /* hasRendered */
          | 16
          /* isQueuedForUpdate */
          )) === 2
          /* hasRendered */
          ) {
              // looks like this value actually changed, so we've got work to do!
              // but only if we've already rendered, otherwise just chill out
              // queue that we need to do an update, but don't worry about queuing
              // up millions cuz this function ensures it only runs once
              scheduleUpdate(elm, hostRef, cmpMeta, false);
            }
        }
      }
    };

    var proxyComponent = function proxyComponent(Cstr, cmpMeta, flags) {
      if (cmpMeta.$members$) {
        if (Cstr.watchers) {
          cmpMeta.$watchers$ = Cstr.watchers;
        } // It's better to have a const than two Object.entries()


        var members = Object.entries(cmpMeta.$members$);
        var prototype = Cstr.prototype;
        members.forEach(function (_ref5) {
          var _ref6 = _slicedToArray(_ref5, 2),
              memberName = _ref6[0],
              _ref6$ = _slicedToArray(_ref6[1], 1),
              memberFlags = _ref6$[0];

          if (memberFlags & 31
          /* Prop */
          || flags & 2
          /* proxyState */
          && memberFlags & 32
          /* State */
          ) {
            // proxyComponent - prop
            Object.defineProperty(prototype, memberName, {
              get: function get() {
                // proxyComponent, get value
                return getValue(this, memberName);
              },
              set: function set(newValue) {
                // proxyComponent, set value
                setValue(this, memberName, newValue, cmpMeta);
              },
              configurable: true,
              enumerable: true
            });
          } else if (flags & 1
          /* isElementConstructor */
          && memberFlags & 64
          /* Method */
          ) {
            // proxyComponent - method
            Object.defineProperty(prototype, memberName, {
              value: function value() {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }

                var ref = getHostRef(this);
                return ref.$onInstancePromise$.then(function () {
                  var _ref$$lazyInstance$;

                  return (_ref$$lazyInstance$ = ref.$lazyInstance$)[memberName].apply(_ref$$lazyInstance$, args);
                });
              }
            });
          }
        });

        if (flags & 1
        /* isElementConstructor */
        ) {
            var attrNameToPropName = new Map();

            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {
              var _this = this;

              plt.jmp(function () {
                var propName = attrNameToPropName.get(attrName);
                _this[propName] = newValue === null && typeof _this[propName] === 'boolean' ? false : newValue;
              });
            }; // create an array of attributes to observe
            // and also create a map of html attribute name to js property name


            Cstr.observedAttributes = members.filter(function (_ref7) {
              var _ref8 = _slicedToArray(_ref7, 2),
                  _ = _ref8[0],
                  m = _ref8[1];

              return m[0] & 15;
            }
            /* HasAttribute */
            ) // filter to only keep props that should match attributes
            .map(function (_ref9) {
              var _ref10 = _slicedToArray(_ref9, 2),
                  propName = _ref10[0],
                  m = _ref10[1];

              var attrName = m[1] || propName;
              attrNameToPropName.set(attrName, propName);

              if (m[0] & 512
              /* ReflectAttr */
              ) {
                  cmpMeta.$attrsToReflect$.push([propName, attrName]);
                }

              return attrName;
            });
          }
      }

      return Cstr;
    };

    var addEventListeners = function addEventListeners(elm, hostRef, listeners) {
      hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || [];
      var removeFns = listeners.map(function (_ref11) {
        var _ref12 = _slicedToArray(_ref11, 3),
            flags = _ref12[0],
            name = _ref12[1],
            method = _ref12[2];

        var target = getHostListenerTarget(elm, flags);
        var handler = hostListenerProxy(hostRef, method);
        var opts = hostListenerOpts(flags);
        plt.ael(target, name, handler, opts);
        return function () {
          return plt.rel(target, name, handler, opts);
        };
      });
      return function () {
        return removeFns.forEach(function (fn) {
          return fn();
        });
      };
    };

    var hostListenerProxy = function hostListenerProxy(hostRef, methodName) {
      return function (ev) {
        {
          if (hostRef.$flags$ & 256
          /* isListenReady */
          ) {
              // instance is ready, let's call it's member method for this event
              hostRef.$lazyInstance$[methodName](ev);
            } else {
            hostRef.$queuedListeners$.push([methodName, ev]);
          }
        }
      };
    };

    var getHostListenerTarget = function getHostListenerTarget(elm, flags) {
      if (flags & 4
      /* TargetDocument */
      ) return doc;
      if (flags & 8
      /* TargetWindow */
      ) return win;
      if (flags & 32
      /* TargetBody */
      ) return doc.body;
      if (flags & 16
      /* TargetParent */
      ) return elm.parentElement;
      return elm;
    };

    var hostListenerOpts = function hostListenerOpts(flags) {
      return supportsListenerOptions ? {
        'passive': (flags & 1
        /* Passive */
        ) !== 0,
        'capture': (flags & 2
        /* Capture */
        ) !== 0
      } : (flags & 2
      /* Capture */
      ) !== 0;
    };

    var initializeClientHydrate = function initializeClientHydrate(hostElm, tagName, hostId, hostRef) {
      var shadowRoot = hostElm.shadowRoot;
      var childRenderNodes = [];
      var slotNodes = [];
      var shadowRootNodes = shadowRoot ? [] : null;
      var vnode = hostRef.$vnode$ = newVNode(tagName, null);

      if (!plt.$orgLocNodes$) {
        initializeDocumentHydrate(doc.body, plt.$orgLocNodes$ = new Map());
      }

      hostElm[HYDRATE_ID] = hostId;
      hostElm.removeAttribute(HYDRATE_ID);
      clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);
      childRenderNodes.forEach(function (c) {
        var orgLocationId = c.$hostId$ + '.' + c.$nodeId$;
        var orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);
        var node = c.$elm$;

        if (orgLocationNode && (orgLocationNode['s-sd'] || c.$hostId$ === '0')) {
          orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);
        }

        if (!shadowRoot) {
          node['s-hn'] = tagName;

          if (orgLocationNode) {
            node['s-ol'] = orgLocationNode;
            node['s-ol']['s-nr'] = node;
          }
        }

        plt.$orgLocNodes$.delete(orgLocationId);
      });

      if (shadowRoot) {
        shadowRootNodes.forEach(function (shadowRootNode) {
          if (shadowRootNode) {
            shadowRoot.appendChild(shadowRootNode);
          }
        });
      }
    };

    var clientHydrate = function clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) {
      var childNodeType;
      var childIdSplt;
      var childVNode;
      var i;

      if (node.nodeType === 1
      /* ElementNode */
      ) {
          childNodeType = node.getAttribute(HYDRATE_CHILD_ID);

          if (childNodeType) {
            // got the node data from the element's attribute
            // `${hostId}.${nodeId}.${depth}.${index}`
            childIdSplt = childNodeType.split('.');

            if (childIdSplt[0] === hostId || childIdSplt[0] === '0') {
              childVNode = {
                $flags$: 0,
                $hostId$: childIdSplt[0],
                $nodeId$: childIdSplt[1],
                $depth$: childIdSplt[2],
                $index$: childIdSplt[3],
                $tag$: node.tagName.toLowerCase(),
                $elm$: node,
                $attrs$: null,
                $children$: null,
                $key$: null,
                $name$: null,
                $text$: null
              };
              childRenderNodes.push(childVNode);
              node.removeAttribute(HYDRATE_CHILD_ID); // this is a new child vnode
              // so ensure its parent vnode has the vchildren array

              if (!parentVNode.$children$) {
                parentVNode.$children$ = [];
              } // add our child vnode to a specific index of the vnode's children


              parentVNode.$children$[childVNode.$index$] = childVNode; // this is now the new parent vnode for all the next child checks

              parentVNode = childVNode;

              if (shadowRootNodes && childVNode.$depth$ === '0') {
                shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
              }
            }
          } // recursively drill down, end to start so we can remove nodes


          for (i = node.childNodes.length - 1; i >= 0; i--) {
            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i], hostId);
          }

          if (node.shadowRoot) {
            // keep drilling down through the shadow root nodes
            for (i = node.shadowRoot.childNodes.length - 1; i >= 0; i--) {
              clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i], hostId);
            }
          }
        } else if (node.nodeType === 8
      /* CommentNode */
      ) {
          // `${COMMENT_TYPE}.${hostId}.${nodeId}.${depth}.${index}`
          childIdSplt = node.nodeValue.split('.');

          if (childIdSplt[1] === hostId || childIdSplt[1] === '0') {
            // comment node for either the host id or a 0 host id
            childNodeType = childIdSplt[0];
            childVNode = {
              $flags$: 0,
              $hostId$: childIdSplt[1],
              $nodeId$: childIdSplt[2],
              $depth$: childIdSplt[3],
              $index$: childIdSplt[4],
              $elm$: node,
              $attrs$: null,
              $children$: null,
              $key$: null,
              $name$: null,
              $tag$: null,
              $text$: null
            };

            if (childNodeType === TEXT_NODE_ID) {
              childVNode.$elm$ = node.nextSibling;

              if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3
              /* TextNode */
              ) {
                  childVNode.$text$ = childVNode.$elm$.textContent;
                  childRenderNodes.push(childVNode); // remove the text comment since it's no longer needed

                  node.remove();

                  if (!parentVNode.$children$) {
                    parentVNode.$children$ = [];
                  }

                  parentVNode.$children$[childVNode.$index$] = childVNode;

                  if (shadowRootNodes && childVNode.$depth$ === '0') {
                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                  }
                }
            } else if (childVNode.$hostId$ === hostId) {
              // this comment node is specifcally for this host id
              if (childNodeType === SLOT_NODE_ID) {
                // `${SLOT_NODE_ID}.${hostId}.${nodeId}.${depth}.${index}.${slotName}`;
                childVNode.$tag$ = 'slot';

                if (childIdSplt[5]) {
                  node['s-sn'] = childVNode.$name$ = childIdSplt[5];
                } else {
                  node['s-sn'] = '';
                }

                node['s-sr'] = true;

                if (shadowRootNodes) {
                  // browser support shadowRoot and this is a shadow dom component
                  // create an actual slot element
                  childVNode.$elm$ = doc.createElement(childVNode.$tag$);

                  if (childVNode.$name$) {
                    // add the slot name attribute
                    childVNode.$elm$.setAttribute('name', childVNode.$name$);
                  } // insert the new slot element before the slot comment


                  node.parentNode.insertBefore(childVNode.$elm$, node); // remove the slot comment since it's not needed for shadow

                  node.remove();

                  if (childVNode.$depth$ === '0') {
                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                  }
                }

                slotNodes.push(childVNode);

                if (!parentVNode.$children$) {
                  parentVNode.$children$ = [];
                }

                parentVNode.$children$[childVNode.$index$] = childVNode;
              } else if (childNodeType === CONTENT_REF_ID) {
                // `${CONTENT_REF_ID}.${hostId}`;
                if (shadowRootNodes) {
                  // remove the content ref comment since it's not needed for shadow
                  node.remove();
                } else {
                  hostElm['s-cr'] = node;
                  node['s-cn'] = true;
                }
              }
            }
          }
        } else if (parentVNode && parentVNode.$tag$ === 'style') {
        var vnode = newVNode(null, node.textContent);
        vnode.$elm$ = node;
        vnode.$index$ = '0';
        parentVNode.$children$ = [vnode];
      }
    };

    var initializeDocumentHydrate = function initializeDocumentHydrate(node, orgLocNodes) {
      if (node.nodeType === 1
      /* ElementNode */
      ) {
          var i = 0;

          for (; i < node.childNodes.length; i++) {
            initializeDocumentHydrate(node.childNodes[i], orgLocNodes);
          }

          if (node.shadowRoot) {
            for (i = 0; i < node.shadowRoot.childNodes.length; i++) {
              initializeDocumentHydrate(node.shadowRoot.childNodes[i], orgLocNodes);
            }
          }
        } else if (node.nodeType === 8
      /* CommentNode */
      ) {
          var childIdSplt = node.nodeValue.split('.');

          if (childIdSplt[0] === ORG_LOCATION_ID) {
            orgLocNodes.set(childIdSplt[1] + '.' + childIdSplt[2], node);
            node.nodeValue = ''; // useful to know if the original location is
            // the root light-dom of a shadow dom component

            node['s-sd'] = childIdSplt[3] === '';
          }
        }
    };

    var modeResolutionChain = [];

    var computeMode = function computeMode(elm) {
      return modeResolutionChain.map(function (h) {
        return h(elm);
      }).find(function (m) {
        return !!m;
      });
    }; // Public


    var setMode = function setMode(handler) {
      return modeResolutionChain.push(handler);
    };

    var getMode = function getMode(ref) {
      return getHostRef(ref).$modeName$;
    };

    var initializeComponent = function initializeComponent(elm, hostRef, cmpMeta, hmrVersionId, Cstr) {
      var _scopeId, style, ancestorComponent, schedule;

      return regeneratorRuntime.async(function initializeComponent$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!((hostRef.$flags$ & 32
              /* hasInitializedComponent */
              ) === 0)) {
                _context2.next = 23;
                break;
              }

              // we haven't initialized this element yet
              hostRef.$flags$ |= 32
              /* hasInitializedComponent */
              ;

              if (hostRef.$modeName$ == null) {
                // initializeComponent
                // looks like mode wasn't set as a property directly yet
                // first check if there's an attribute
                // next check the app's global
                hostRef.$modeName$ = typeof cmpMeta.$lazyBundleIds$ !== 'string' ? computeMode(elm) : '';
              }

              // lazy loaded components
              // request the component's implementation to be
              // wired up with the host element
              Cstr = loadModule(cmpMeta, hostRef);

              if (!Cstr.then) {
                _context2.next = 8;
                break;
              }

              _context2.next = 7;
              return regeneratorRuntime.awrap(Cstr);

            case 7:
              Cstr = _context2.sent;

            case 8:
              if (!Cstr.isProxied) {
                // we'eve never proxied this Constructor before
                // let's add the getters/setters to its prototype before
                // the first time we create an instance of the implementation
                {
                  cmpMeta.$watchers$ = Cstr.watchers;
                }
                proxyComponent(Cstr, cmpMeta, 2
                /* proxyState */
                );
                Cstr.isProxied = true;
              } // ok, time to construct the instance
              // but let's keep track of when we start and stop
              // so that the getters/setters don't incorrectly step on data


              hostRef.$flags$ |= 8
              /* isConstructingInstance */
              ;

              // construct the lazy-loaded component implementation
              // passing the hostRef is very important during
              // construction in order to directly wire together the
              // host element and the lazy-loaded instance
              try {
                new Cstr(hostRef);
              } catch (e) {
                consoleError(e);
              }

              hostRef.$flags$ &= ~8
              /* isConstructingInstance */
              ;
              hostRef.$flags$ |= 128
              /* isWatchReady */
              ;
              fireConnectedCallback(hostRef.$lazyInstance$);
              _scopeId = getScopeId(cmpMeta.$tagName$, hostRef.$modeName$);

              if (!(!styles.has(_scopeId) && Cstr.style)) {
                _context2.next = 23;
                break;
              }

              // this component has styles but we haven't registered them yet
              style = Cstr.style;

              if (typeof style !== 'string') {
                style = style[hostRef.$modeName$];
              }

              if (!(cmpMeta.$flags$ & 8
              /* needsShadowDomShim */
              )) {
                _context2.next = 22;
                break;
              }

              _context2.next = 21;
              return regeneratorRuntime.awrap(__webpack_require__.e(
              /*! import() | shadow-css-4889ae62-23996f3f-js */
              "shadow-css-4889ae62-23996f3f-js").then(__webpack_require__.bind(null,
              /*! ./shadow-css-4889ae62-23996f3f.js */
              "./node_modules/@ionic/core/dist/esm/shadow-css-4889ae62-23996f3f.js")).then(function (m) {
                return m.scopeCss(style, _scopeId, false);
              }));

            case 21:
              style = _context2.sent;

            case 22:
              registerStyle(_scopeId, style, !!(cmpMeta.$flags$ & 1
              /* shadowDomEncapsulation */
              ));

            case 23:
              // we've successfully created a lazy instance
              ancestorComponent = hostRef.$ancestorComponent$;

              schedule = function schedule() {
                return scheduleUpdate(elm, hostRef, cmpMeta, true);
              };

              if (ancestorComponent && ancestorComponent['s-rc']) {
                // this is the intial load and this component it has an ancestor component
                // but the ancestor component has NOT fired its will update lifecycle yet
                // so let's just cool our jets and wait for the ancestor to continue first
                // this will get fired off when the ancestor component
                // finally gets around to rendering its lazy self
                // fire off the initial update
                ancestorComponent['s-rc'].push(schedule);
              } else {
                schedule();
              }

            case 26:
            case "end":
              return _context2.stop();
          }
        }
      });
    };

    var fireConnectedCallback = function fireConnectedCallback(instance) {
      {
        safeCall(instance, 'connectedCallback');
      }
    };

    var _connectedCallback = function connectedCallback(elm, cmpMeta) {
      if ((plt.$flags$ & 1
      /* isTmpDisconnected */
      ) === 0) {
        // connectedCallback
        var hostRef = getHostRef(elm);

        if (cmpMeta.$listeners$) {
          // initialize our event listeners on the host element
          // we do this now so that we can listening to events that may
          // have fired even before the instance is ready
          hostRef.$rmListeners$ = addEventListeners(elm, hostRef, cmpMeta.$listeners$);
        }

        if (!(hostRef.$flags$ & 1
        /* hasConnected */
        )) {
          // first time this component has connected
          hostRef.$flags$ |= 1
          /* hasConnected */
          ;
          var hostId;
          {
            hostId = elm.getAttribute(HYDRATE_ID);

            if (hostId) {
              if (supportsShadowDom && cmpMeta.$flags$ & 1
              /* shadowDomEncapsulation */
              ) {
                  var _scopeId2 = addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute('s-mode'));

                  elm.classList.remove(_scopeId2 + '-h');
                  elm.classList.remove(_scopeId2 + '-s');
                }

              initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);
            }
          }

          if (!hostId) {
            // initUpdate
            // if the slot polyfill is required we'll need to put some nodes
            // in here to act as original content anchors as we move nodes around
            // host element has been connected to the DOM
            if (cmpMeta.$flags$ & 4
            /* hasSlotRelocation */
            || cmpMeta.$flags$ & 8
            /* needsShadowDomShim */
            ) {
              setContentReference(elm);
            }
          }

          {
            // find the first ancestor component (if there is one) and register
            // this component as one of the actively loading child components for its ancestor
            var ancestorComponent = elm;

            while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {
              // climb up the ancestors looking for the first
              // component that hasn't finished its lifecycle update yet
              if (ancestorComponent.nodeType === 1
              /* ElementNode */
              && ancestorComponent.hasAttribute('s-id') || ancestorComponent['s-p']) {
                // we found this components first ancestor component
                // keep a reference to this component's ancestor component
                attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
                break;
              }
            }
          } // Lazy properties
          // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties

          if (cmpMeta.$members$) {
            Object.entries(cmpMeta.$members$).forEach(function (_ref13) {
              var _ref14 = _slicedToArray(_ref13, 2),
                  memberName = _ref14[0],
                  _ref14$ = _slicedToArray(_ref14[1], 1),
                  memberFlags = _ref14$[0];

              if (memberFlags & 31
              /* Prop */
              && elm.hasOwnProperty(memberName)) {
                var value = elm[memberName];
                delete elm[memberName];
                elm[memberName] = value;
              }
            });
          }

          {
            // connectedCallback, taskQueue, initialLoad
            // angular sets attribute AFTER connectCallback
            // https://github.com/angular/angular/issues/18909
            // https://github.com/angular/angular/issues/19940
            nextTick(function () {
              return initializeComponent(elm, hostRef, cmpMeta);
            });
          }
        }

        fireConnectedCallback(hostRef.$lazyInstance$);
      }
    };

    var setContentReference = function setContentReference(elm) {
      // only required when we're NOT using native shadow dom (slot)
      // or this browser doesn't support native shadow dom
      // and this host element was NOT created with SSR
      // let's pick out the inner content for slot projection
      // create a node to represent where the original
      // content was first placed, which is useful later on
      var crName = '';
      var contentRefElm = elm['s-cr'] = doc.createComment(crName);
      contentRefElm['s-cn'] = true;
      elm.insertBefore(contentRefElm, elm.firstChild);
    };

    var _disconnectedCallback = function disconnectedCallback(elm) {
      if ((plt.$flags$ & 1
      /* isTmpDisconnected */
      ) === 0) {
        var hostRef = getHostRef(elm);
        var instance = hostRef.$lazyInstance$;
        {
          if (hostRef.$rmListeners$) {
            hostRef.$rmListeners$();
            hostRef.$rmListeners$ = undefined;
          }
        } // clear CSS var-shim tracking

        if (plt.$cssShim$) {
          plt.$cssShim$.removeHost(elm);
        }

        {
          safeCall(instance, 'disconnectedCallback');
        }
        {
          safeCall(instance, 'componentDidUnload');
        }
      }
    };

    var bootstrapLazy = function bootstrapLazy(lazyBundles) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var cmpTags = [];
      var exclude = options.exclude || [];
      var head = doc.head;
      var customElements = win.customElements;
      var y =
      /*@__PURE__*/
      head.querySelector('meta[charset]');
      var visibilityStyle =
      /*@__PURE__*/
      doc.createElement('style');
      var appLoadFallback;
      Object.assign(plt, options);
      plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;

      if (options.syncQueue) {
        plt.$flags$ |= 4
        /* queueSync */
        ;
      }

      {
        // If the app is already hydrated there is not point to disable the
        // async queue. This will improve the first input delay
        plt.$flags$ |= 2
        /* appLoaded */
        ;
      }
      {
        var _styles = doc.querySelectorAll('style[s-id]');

        var globalStyles = '';
        var i = 0;

        for (; i < _styles.length; i++) {
          globalStyles += _styles[i].innerHTML;
        }

        for (i = 0; i < _styles.length; i++) {
          var styleElm = _styles[i];
          registerStyle(styleElm.getAttribute(HYDRATE_ID), globalStyles + convertScopedToShadow(styleElm.innerHTML), true);
        }
      }
      lazyBundles.forEach(function (lazyBundle) {
        return lazyBundle[1].forEach(function (compactMeta) {
          var cmpMeta = {
            $flags$: compactMeta[0],
            $tagName$: compactMeta[1],
            $members$: compactMeta[2],
            $listeners$: compactMeta[3]
          };
          {
            cmpMeta.$members$ = compactMeta[2];
          }
          {
            cmpMeta.$listeners$ = compactMeta[3];
          }
          {
            cmpMeta.$attrsToReflect$ = [];
          }
          {
            cmpMeta.$watchers$ = {};
          }

          if (!supportsShadowDom && cmpMeta.$flags$ & 1
          /* shadowDomEncapsulation */
          ) {
              cmpMeta.$flags$ |= 8
              /* needsShadowDomShim */
              ;
            }

          var tagName = cmpMeta.$tagName$;

          var HostElement =
          /*#__PURE__*/
          function (_HTMLElement) {
            _inherits(HostElement, _HTMLElement);

            // StencilLazyHost
            function HostElement(self) {
              var _this2;

              _classCallCheck(this, HostElement);

              // @ts-ignore
              _this2 = _possibleConstructorReturn(this, _getPrototypeOf(HostElement).call(this, self));
              self = _assertThisInitialized(_this2);
              registerHost(self);

              if (cmpMeta.$flags$ & 1
              /* shadowDomEncapsulation */
              ) {
                  // this component is using shadow dom
                  // and this browser supports shadow dom
                  // add the read-only property "shadowRoot" to the host element
                  if (supportsShadowDom) {
                    self.attachShadow({
                      'mode': 'open'
                    });
                  } else if (!('shadowRoot' in self)) {
                    self.shadowRoot = self;
                  }
                }

              return _this2;
            }

            _createClass(HostElement, [{
              key: "connectedCallback",
              value: function connectedCallback() {
                var _this3 = this;

                if (appLoadFallback) {
                  clearTimeout(appLoadFallback);
                  appLoadFallback = null;
                }

                plt.jmp(function () {
                  return _connectedCallback(_this3, cmpMeta);
                });
              }
            }, {
              key: "disconnectedCallback",
              value: function disconnectedCallback() {
                var _this4 = this;

                plt.jmp(function () {
                  return _disconnectedCallback(_this4);
                });
              }
            }, {
              key: 's-hmr',
              value: function sHmr(hmrVersionId) {}
            }, {
              key: "forceUpdate",
              value: function forceUpdate() {
                _forceUpdate(this, cmpMeta);
              }
            }, {
              key: "componentOnReady",
              value: function componentOnReady() {
                return getHostRef(this).$onReadyPromise$;
              }
            }]);

            return HostElement;
          }(_wrapNativeSuper(HTMLElement));

          cmpMeta.$lazyBundleIds$ = lazyBundle[0];

          if (!exclude.includes(tagName) && !customElements.get(tagName)) {
            cmpTags.push(tagName);
            customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1
            /* isElementConstructor */
            ));
          }
        });
      }); // visibilityStyle.innerHTML = cmpTags.map(t => `${t}:not(.hydrated)`) + '{display:none}';

      visibilityStyle.innerHTML = cmpTags + '{visibility:hidden}.hydrated{visibility:inherit}';
      visibilityStyle.setAttribute('data-styles', '');
      head.insertBefore(visibilityStyle, y ? y.nextSibling : head.firstChild); // Fallback appLoad event

      plt.jmp(function () {
        return appLoadFallback = setTimeout(appDidLoad, 30);
      });
    };

    var createEvent = function createEvent(ref, name, flags) {
      var elm = getElement(ref);
      return {
        emit: function emit(detail) {
          return elm.dispatchEvent(new CustomEvent(name, {
            bubbles: !!(flags & 4
            /* Bubbles */
            ),
            composed: !!(flags & 2
            /* Composed */
            ),
            cancelable: !!(flags & 1
            /* Cancellable */
            ),
            detail: detail
          }));
        }
      };
    };

    var getAssetPath = function getAssetPath(path) {
      var assetUrl = new URL(path, plt.$resourcesUrl$);
      return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;
    };

    var getElement = function getElement(ref) {
      return getHostRef(ref).$hostElement$;
    };

    var mode;

    var getIonMode = function getIonMode(ref) {
      return ref && getMode(ref) || mode;
    };

    var global0 = function global0() {
      var doc = document;
      var win = window;
      var Ionic = win.Ionic = win.Ionic || {}; // Setup platforms

      Object(_config_3c7f3790_js__WEBPACK_IMPORTED_MODULE_0__["s"])(win); // create the Ionic.config from raw config object (if it exists)
      // and convert Ionic.config into a ConfigApi that has a get() fn

      var configObj = Object.assign(Object.assign(Object.assign(Object.assign({}, Object(_config_3c7f3790_js__WEBPACK_IMPORTED_MODULE_0__["c"])(win)), {
        persistConfig: false
      }), Ionic.config), Object(_config_3c7f3790_js__WEBPACK_IMPORTED_MODULE_0__["a"])(win));

      _config_3c7f3790_js__WEBPACK_IMPORTED_MODULE_0__["b"].reset(configObj);

      if (_config_3c7f3790_js__WEBPACK_IMPORTED_MODULE_0__["b"].getBoolean('persistConfig')) {
        Object(_config_3c7f3790_js__WEBPACK_IMPORTED_MODULE_0__["d"])(win, configObj);
      } // first see if the mode was set as an attribute on <html>
      // which could have been set by the user, or by prerendering
      // otherwise get the mode via config settings, and fallback to md


      Ionic.config = _config_3c7f3790_js__WEBPACK_IMPORTED_MODULE_0__["b"];
      Ionic.mode = mode = _config_3c7f3790_js__WEBPACK_IMPORTED_MODULE_0__["b"].get('mode', doc.documentElement.getAttribute('mode') || (Object(_config_3c7f3790_js__WEBPACK_IMPORTED_MODULE_0__["i"])(win, 'ios') ? 'ios' : 'md'));

      _config_3c7f3790_js__WEBPACK_IMPORTED_MODULE_0__["b"].set('mode', mode);

      doc.documentElement.setAttribute('mode', mode);
      doc.documentElement.classList.add(mode);

      if (_config_3c7f3790_js__WEBPACK_IMPORTED_MODULE_0__["b"].getBoolean('_testing')) {
        _config_3c7f3790_js__WEBPACK_IMPORTED_MODULE_0__["b"].set('animated', false);
      }

      setMode(function (elm) {
        return elm.mode = elm.mode || elm.getAttribute('mode') || mode;
      });
    };

    var global1 = function global1() {
      setMode(function (el) {
        return el.tagName === 'ION-ICON' ? el.mode || el.getAttribute('mode') : null;
      });
    };

    var globals = function globals() {
      global0();
      global1();
    };
    /***/

  }
}]);
//# sourceMappingURL=1-es5.js.map